<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FIGAB CAPITAL PARTNERS</title>
<link rel="stylesheet" href="{{ url_for('static', filename='css/portfolio.css') }}">
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/date-fns@2.29.3/dist/date-fns.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
<link rel="icon" type="image/x-icon" href="{{ url_for('static', filename='favicon.ico') }}">
</head>
<body>
<header>
    <div class="top-bar">
        <h1>FIGAB CAPITAL PARTNERS</h1>
        <nav id="menu">
            <ul>
                <li><a href="/">Home</a></li>
                <li><a href="/reports">Reports</a></li>
            </ul>
        </nav>
    </div>
</header>

<main>
    <!-- Summary Cards -->
    <section class="summary">
        <div class="summary-item">
            <h2>Totalt värde</h2>
            <p>{{ latest_value }} SEK</p>
        </div>
        <div class="summary-item">
            <h2>Likviditet</h2>
            <p>{{ cash }} SEK</p>
        </div>
    </section>

    <!-- Percent Changes -->
    <section class="percent-changes">
        <h2>Procentuell förändring</h2>
        <ul>
            {% for key, value in pct_changes.items() %}
            <li>{{ key }}: {{ "%.2f"|format(value) if value is not none else "N/A" }}%</li>
            {% endfor %}
        </ul>
    </section>

    <!-- Charts -->
    <section class="charts">
        <div class="chart-container full-width">
            <div class="chart-header">
                <h3>Portföljens utveckling</h3>
                <div class="button-container">
                    <button onclick="setTimeRange('1m')">1 m.</button>
                    <button onclick="setTimeRange('3m')">3 m.</button>
                    <button onclick="setTimeRange('1y')">1 yr.</button>
                    <button onclick="setTimeRange('all')">All</button>
                </div>
            </div>
            <canvas id="valueChart"></canvas>
        </div>
    </section>


<section class="info-sections">

    <!-- Left column: Nuvarande + Tidigare innehav -->
    <div class="info-column">
        <div class="collapsible-section">
            <div class="collapsible-header">
                <h3>Nuvarande innehav</h3><span class="arrow">▶</span>
            </div>
            <div class="collapsible-content">
                <ul>{% for item in current %}<li>{{ item }}</li>{% endfor %}</ul>
            </div>
        </div>

        <div class="collapsible-section">
            <div class="collapsible-header">
                <h3>Tidigare innehav</h3><span class="arrow">▶</span>
            </div>
            <div class="collapsible-content">
                <ul>{% for item in past %}<li>{{ item }}</li>{% endfor %}</ul>
            </div>
        </div>
    </div>

    <!-- Right column: Stadgar -->
    <div class="info-column">
        <div class="collapsible-section">
            <div class="collapsible-header">
                <h3>Stadgar</h3><span class="arrow">▶</span>
            </div>
            <div class="collapsible-content">
                <ol>
                    <li>...</li>
                    <li>...</li>
                </ol>
            </div>
        </div>
    </div>

</section>

</main>

<script src="{{ url_for('static', filename='js/script.js') }}"></script>
<script>

document.querySelectorAll('.collapsible-header').forEach(header => {
    header.addEventListener('click', () => {
        header.classList.toggle('active');
        const content = header.nextElementSibling;
        if (content.style.maxHeight) {
            content.style.maxHeight = null;
            content.classList.remove('open');
        } else {
            content.style.maxHeight = content.scrollHeight + 20 + "px";
            content.classList.add('open');
        }
    });
});

const isDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;

const valueChartColors = {
    border: isDark ? '#3a86ff' : '#3a86ff',
    background: isDark ? 'rgba(58,134,255,0.2)' : 'rgba(58,134,255,0.2)',
    omxBorder: isDark ? '#ff006e' : '#ff006e',
    gspcBorder: isDark ? '#fb5607' : '#fb5607'
};

const ctxValue = document.getElementById('valueChart').getContext('2d');
const valueChart = new Chart(ctxValue, {
    type: 'line',
    data: {
        labels: {{ line_labels | tojson }},
        interaction: {
            mode: 'index',
            intersect: false,
            axis: 'x' 
        },
        datasets: [
            {
                label: 'Portfolio Value',
                data: {{ line_data | tojson }},
                borderColor: 'rgba(75, 192, 192, 1)',
                backgroundColor: 'rgba(75, 192, 192, 0.2)',
                fill: true,
                pointRadius: 2,
                pointHoverRadius: 4,
                tension: 0.2
            },
            {
                label: '^OMX',
                data: {{ omx_data | tojson }},
                borderColor: valueChartColors.omxBorder,
                backgroundColor: 'transparent',
                fill: false,
                pointRadius: 0,
                borderDash: [5,5],
                tension:0.1
            },
            {
                label: '^GSPC',
                data: {{ gspc_data | tojson }},
                borderColor: valueChartColors.gspcBorder,
                backgroundColor: 'transparent',
                fill: false,
                pointRadius: 0,
                borderDash: [5,5],
                tension:0.1
            }
        ]
    },
    options: {
        responsive:true,
        maintainAspectRatio:false,
        plugins: {
            tooltip: {
                enabled: true,
                mode: 'index',
                intersect: false,
                position: 'nearest', // follows cursor/finger
                callbacks: {
                    label: function(context) {
                        let label = context.dataset.label || '';
                        let value = context.parsed.y;
                        return `${label}: ${value.toLocaleString('sv-SE')} SEK`; // format nicely
                    }
                }
            },
            legend: {
                display: true,
                labels: { color: isDark ? '#e2e7e5' : '#1f2937' }
            }
        },
        scales: {
            x: { 
                
                ticks: { color: isDark ? '#e2e7e5' : '#1f2937',
                autoSkip: true,       // Automatically skip labels that don’t fit
                maxRotation: 30,       // No rotation
                minRotation: 30
                },
                title: { color: isDark ? '#e2e7e5' : '#1f2937' }
            },
            y: { 
                ticks: { color: isDark ? '#e2e7e5' : '#1f2937' },
                title: { color: isDark ? '#e2e7e5' : '#1f2937' }
            }
        }
    }
});



function setTimeRange(range) {
    const fullLabels = {{ line_labels | tojson }};
    const fullData = {{ line_data | tojson }};
    const omxFull = {{ omx_data | tojson }};
    const gspcFull = {{ gspc_data | tojson }};

    const now = new Date();
    let fromDate;
    if(range==='1m'){ fromDate = new Date(now.setMonth(now.getMonth()-1)); }
    else if(range==='3m'){ fromDate = new Date(now.setMonth(now.getMonth()-3)); }
    else if(range==='1y'){ fromDate = new Date(now.setFullYear(now.getFullYear()-1)); }
    else{ fromDate = new Date('1970-01-01'); }

    let fLabels=[], fPortfolio=[], fOMX=[], fGSPC=[];
    for(let i=0;i<fullLabels.length;i++){
        const d = new Date(fullLabels[i]);
        if(d>=fromDate){
            fLabels.push(fullLabels[i]);
            fPortfolio.push(fullData[i]);
            fOMX.push(omxFull[i]);
            fGSPC.push(gspcFull[i]);
        }
    }
    if(fPortfolio.length===0) return;

    const base=fPortfolio[0], omxBase=fOMX[0], gspcBase=fGSPC[0];
    const rebasedOMX=fOMX.map(v=>v*(base/omxBase));
    const rebasedGSPC=fGSPC.map(v=>v*(base/gspcBase));

    const combined=[...fPortfolio,...rebasedOMX,...rebasedGSPC];
    const minY=Math.floor(Math.min(...combined)/10000)*10000;
    const maxY=Math.ceil(Math.max(...combined)/10000)*10000;
    const padding=(maxY-minY)*0.05;

    valueChart.options.scales.y.min = Math.floor(minY-padding);
    valueChart.options.scales.y.max = Math.ceil(maxY+padding);
    valueChart.data.labels=fLabels;
    valueChart.data.datasets[0].data=fPortfolio;
    valueChart.data.datasets[1].data=rebasedOMX;
    valueChart.data.datasets[2].data=rebasedGSPC;
    valueChart.update();
}

document.querySelectorAll('.button-container button').forEach(btn=>{
    btn.addEventListener('click',function(){
        document.querySelectorAll('.button-container button').forEach(b=>b.classList.remove('active'));
        this.classList.add('active');
    });
});



</script>
</body>
</html>
